 # Principles of Design Patterns 

- 设计模式一般遵循的设计原则
  
---
- [Principles of Design Patterns](#principles-of-design-patterns)
  - [1. 开闭原则](#1-开闭原则)
    - [1.1 OCP 作用](#11-ocp-作用)
    - [1.2 OCP 实现方法](#12-ocp-实现方法)
  - [2. 里氏替换原则](#2-里氏替换原则)
    - [2.1 LSP 作用](#21-lsp-作用)
    - [2.2 LSP 实现方法](#22-lsp-实现方法)
  - [3. 依赖倒置原则](#3-依赖倒置原则)
    - [3.1 DIP 简介](#31-dip-简介)
    - [3.2 DIP 作用](#32-dip-作用)
    - [3.3 DIP 实现方法](#33-dip-实现方法)
  - [4. 单一职责原则](#4-单一职责原则)
    - [4.1 SRP 作用](#41-srp-作用)
    - [4.2 SRP 实现方法](#42-srp-实现方法)
  - [5. 接口隔离原则](#5-接口隔离原则)
    - [5.1 ISP 简介](#51-isp-简介)
    - [5.2 ISP 优点](#52-isp-优点)
    - [5.3 ISP 实现方法](#53-isp-实现方法)
  - [6. 迪米特原则](#6-迪米特原则)
    - [6.1 LKP 简介](#61-lkp-简介)
    - [6.2 LKP 优点](#62-lkp-优点)
    - [6.3 LKP 实现方法](#63-lkp-实现方法)
  - [7. 合成复用原则](#7-合成复用原则)
    - [7.1 CRP 简介](#71-crp-简介)
    - [7.2 CRP 重要性](#72-crp-重要性)
    - [7.3 CRP 实现方法](#73-crp-实现方法)
  - [8. 通用职责分配软件模式 (GRASP)](#8-通用职责分配软件模式-grasp)
    - [8.1 创建者 (Creator)](#81-创建者-creator)
    - [8.2 信息专家 (Information Expert)](#82-信息专家-information-expert)
    - [8.3 低耦合 (Low Coupling)](#83-低耦合-low-coupling)
    - [8.4 高内聚 (High Cohesion)](#84-高内聚-high-cohesion)
    - [8.5 控制器 (Controller)](#85-控制器-controller)
    - [8.6 多态 (Polymorphism)](#86-多态-polymorphism)
    - [8.7 纯虚构 (Pure Fabrication)](#87-纯虚构-pure-fabrication)
    - [8.8 间接性 (Indirection)](#88-间接性-indirection)
    - [8.9 防止异变 (Protected Variations)](#89-防止异变-protected-variations)

---
## 1. 开闭原则 

**开闭原则** (The Open/Closed Principle，OCP) 规定 **软件中的对象 (类，模块，函数等等) 应该对于扩展是开放的，但是对于修改是封闭的**。

>---
### 1.1 OCP 作用

开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。

1. 对软件测试的影响：软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了因为原有的测试代码仍然能够正常运行。
2. 可以提高代码的可复用性：粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。
3. 可以提高软件的可维护性：遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

---
### 1.2 OCP 实现方法

可以通过 “**抽象约束、封装变化**” 来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

---
## 2. 里氏替换原则

**里氏替换原则** (Liskov Substitution Principle，LSP) 描述为 **派生类 (子类) 对象可以在程序中代替其基类 (超类) 对象**。

里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

>---
### 2.1 LSP 作用

- 里氏替换原则是实现开闭原则的重要方式之一。
- 它克服了继承中重写父类造成的可复用性变差的缺点。
- 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
- 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。

>---
### 2.2 LSP 实现方法

里氏替换原则通俗来讲就是：**子类可以扩展父类的功能，但不能改变父类原有的功能**。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
  - 子类可以实现父类的抽象方法，但不应覆盖父类的非抽象方法。
  - 子类中可以增加自己特有的方法。
  - 当子类的方法重载父类的方法时，方法的前置条件 (即方法的输入参数) 要比父类的方法更宽松。
  - 当子类的方法实现父类的方法时 (重写 / 重载或实现抽象方法) ，方法的后置条件 (即方法的的输出 / 返回值) 要比父类的方法更严格或相等。

---
## 3. 依赖倒置原则

**依赖倒置原则** (Dependence Inversion Principle，DIP) 描述 **程序要依赖于抽象接口，不要依赖于具体实现**。

>---
### 3.1 DIP 简介

依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。

由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。使用接口或者抽象类的目的是制定好规范和契约，而不涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。

>---
### 3.2 DIP 作用

- 依赖倒置原则可以降低类间的耦合性。
- 依赖倒置原则可以提高系统的稳定性。
- 依赖倒置原则可以减少并行开发引起的风险。
- 依赖倒置原则可以提高代码的可读性和可维护性。

>---
### 3.3 DIP 实现方法

依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以在实际编程中只要遵循以下 4 点，就能在项目中满足这个规则：
  - 每个类尽量提供接口或抽象类，或者两者都具备。
  - 变量的声明类型尽量是接口或者是抽象类。
  - 任何类都不应该从具体类派生。
  - 使用继承时尽量遵循里氏替换原则。

---
## 4. 单一职责原则

**单一职责原则** (Single Responsibility Principle，SRP) 规定 **一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分**。

>---
### 4.1 SRP 作用

单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点：
  - 降低类的复杂度。**一个类只负责一项职责**，其逻辑肯定要比负责多项职责简单得多。
  - 提高类的可读性。复杂性降低，自然其可读性会提高。
  - 提高系统的可维护性。可读性提高，那自然更容易维护了。
  - 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

>---
### 4.2 SRP 实现方法

单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。

---
## 5. 接口隔离原则

**接口隔离原则** (Interface Segregation Principle，ISP) 要求程序员尽量 **将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法**。

>---
### 5.1 ISP 简介

**接口隔离原则** 的定义是：客户端不应该被迫依赖于它不使用的方法 (该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上) 。

接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：
  - 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
  - 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

>---
### 5.2 ISP 优点

接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点：
  - 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
  - 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
  - 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
  - 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
  - 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

>---
### 5.3 ISP 实现方法

在具体应用接口隔离原则时，应该根据以下几个规则来衡量：
  - 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
  - 为依赖接口的类定制服务。只提供调用方需要的方法，屏蔽不需要的方法。
  - 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同。这就需要深入了解业务逻辑。
  - 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

---
## 6. 迪米特原则

**迪米特法则** (Law of Demeter，LoD) 又叫作最少知识原则 (Least Knowledge Principle，LKP)。

>---
### 6.1 LKP 简介

**迪米特法则的定义** 是：只与你的直接朋友交谈，不跟 “陌生人” 说话 (Talk only to your immediate friends and not to strangers) 。其含义是：**如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用**。其目的是降低类之间的耦合度，提高模块的相对独立性。

迪米特法则中的 **朋友** 是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

>---
### 6.2 LKP 优点

迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点：
  - 降低了类之间的耦合度，提高了模块的相对独立性。
  - 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。

>---
### 6.3 LKP 实现方法

从迪米特法则的定义和特点可知，它强调以下两点：
  1. 从依赖者的角度来说，只依赖应该依赖的对象。
  2. 从被依赖者的角度说，只暴露应该暴露的方法。

所以，在运用迪米特法则时要注意以下 6 点：
  1. 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
  2. 在类的结构设计上，尽量降低类成员的访问权限。
  3. 在类的设计上，优先考虑将一个类设置成不变类。
  4. 在对其他类的引用上，将引用其他对象的次数降到最低。
  5. 不暴露类的属性成员，而应该提供相应的访问器 (set 和 get 方法) 。
  6. 谨慎使用序列化 (Serializable) 功能。

---
## 7. 合成复用原则

**合成复用原则** (Composite Reuse Principle，CRP) 又叫组合 / 聚合复用原则 (Composition/Aggregate Reuse Principle，CARP)。

>---
### 7.1 CRP 简介

**合成复用要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现**。

如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。

>---
### 7.2 CRP 重要性

通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点：
  1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为 “白箱” 复用。
  2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
  3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。
  
采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：
  1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为 “黑箱” 复用。
  2. 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
  3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

>---
### 7.3 CRP 实现方法

合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。

---
## 8. 通用职责分配软件模式 (GRASP) 

GRASP (General Responsibility Assignment Software) 通用职责分配软件模式，包括 4 个基本模式和 5 个扩展模式，描述了对象设计和职责分配的基本原则。

>---
### 8.1 创建者 (Creator) 

对象的创建是面向对象系统中最常见的活动。**哪个类负责创建对象是衡量特定类的对象之间关系的一个重要特征，降低类与类之间的耦合度**。

实际应用中，符合下列任一条件的时候，都应该由类 A 来创建类 B，这时 A 是 B 的创建者：
  - A 是 B 的聚合或容器。
  - A 持有初始化 B 的信息 (数据)。
  - A 记录 B 的实例。
  - A 频繁使用 B。

创建者指导我们分配与创建对象相关的职责，不会增加耦合性，因为所创建的类与创建者之间本身已经存在关联。

>---
### 8.2 信息专家 (Information Expert) 

信息专家 (也称专家或专家原则) 是一个用于确定将职责委托给谁的原则。分配职责的一般方法是查看给定的职责所需信息存储在哪里。**把职责分配给具有履行该职责所需信息最多的类**。

信息专家模式经常用于职责分配，完成职责往往需要分布在不同对象中的信息，许多 “局部” 的信息专家要通过协作来完成任务。

信息专家要求对象只完成与它们所知信息相关的职责，因此处于该对象的信息的封装性的得以维持。

>---
### 8.3 低耦合 (Low Coupling) 

**耦合是对某元素和其他元素之间的链接、感知和依赖程度的度量**。低耦合度是一种评价模式，它决定了如何分配职责以获得以下好处：
  - 降低类之间的依赖性。
  - 一个类的变化对其他类的影响较小。
  - 更高的重用潜力。

低耦合是在制定设计决策期间需要牢记的原则，是评估所有设计结果时要运用的评估原则。低耦合不能脱离专家和高内聚等模式孤立地考虑，应该作为影响职责分配的原则之一。

没有绝对的度量标准来衡量耦合程度的高低 (高低是一个相对的概念)。重要的是能够估测当前的耦合程度，评估增加耦合是否会导致问题。

>---
### 8.4 高内聚 (High Cohesion) 

高内聚是一种评估模式，使用该模式可以让对象保持适当的集中性、可管理性和可理解性。高内聚通常用于支持低耦合。

**高内聚意味着给定元素的职责是紧密相关且高度集中的**。将程序分解成类和子系统是增加系统内聚性的活动的一个例子。另外，低内聚性是指给定元素承担了太多不相关的职责。内聚性低的元素通常难以理解、复用、维护和更改。

**内聚是对元素职责的相关性和集中度的度量。如果元素具有高度相关的职责，而且只完成有限的功能，则这个元素就具有高内聚性。**

>---
### 8.5 控制器 (Controller) 

控制器模式将处理系统事件的责任分配给一个代表整体系统或用例场景的非 UI 类。**控制器对象是一个非用户界面对象，负责接收或处理系统事件。**

把接收和协调 (控制) 系统事件的职责分配给一个类，这个类可以代表：
  - 整个系统、设备或者子系统。
  - 系统事件发生时对应的用例场景，在相同的用例场景中使用相同的控制器来处理所有的系统事件。

通常，控制器应当把要完成的工作委派给其他对象，它只负责协调或控制，本身并不完成太多功能。

>---
### 8.6 多态 (Polymorphism) 

根据多态原则，定义基于类型的行为变化，并由发生这种变化的类型负责。这是使用多态操作实现的。不同类型应使用多态操作，而不是基于类型的显式分支。**当相关选择或行为随类型而变化时，使用多态操作来为变化的行为分配职责**。

不要测试对象的类型，也不要使用条件逻辑来执行基于类型的不同选择。如果我们使用 `if-else` 或 `switch` 语句来执行不同类型的分支，当出现新的变化时，往往需要修改散落在各处的 `if` 语句，让软件难以维护，也容易出现缺陷。

>---
### 8.7 纯虚构 (Pure Fabrication) 

**纯虚构类并不表示具体的业务领域概念，把它构造出来是为了达到低耦合、高内聚的目的**，因此也提供了复用的潜力 (当基于信息专家的方案无法实现这些目的时)。

如果信息专家所提供的方案，能够实现低耦合、高内聚，那没有必要用纯虚构，可以直接采用信息专家方案；当信息专家方案无法实现低耦合和高内聚时，那可以引入纯虚构方案。

基本所有的设计模式都是纯虚构，比如控制器，适配器，观察者。

>---
### 8.8 间接性 (Indirection) 

**间接性模式通过将两个元素之间的协调职责分配给一个中介对象**，来实现两个元素之间的低耦合以及提高其可复用的潜力。

将职责分配给中介对象，使其作为其他构件或服务之间的媒介，以避免他们之间的直接耦合。中介实现了其他构件之间的间接性。

>---
### 8.9 防止异变 (Protected Variations) 

**防止变异通过提供稳定接口 (并利用多态来创建这个接口的各种实现)**，从而保护元素不受其他元素 (对象、系统、子系统) 变化的影响。识别预计变化或不稳定之处，分配职责以在这些变化之外创建稳定接口。

防止变异是最基本的软件设计原则，大部分设计原则和模式都是防止异变的机制。

---
# Strategy Pattern

---

- [Strategy Pattern](#strategy-pattern)
- [1. 策略模式(Strategy)](#1-策略模式strategy)
- [2. 意图](#2-意图)
- [3. 动机](#3-动机)
- [4. 适用性](#4-适用性)
- [5. 结构与参与者](#5-结构与参与者)
- [6. 策略模式优缺点](#6-策略模式优缺点)
- [7. 实现](#7-实现)
- [8. 设计要点](#8-设计要点)
- [9. 案例实现](#9-案例实现)
- [10. 相关模式](#10-相关模式)

---
# 1. 策略模式(Strategy)

- 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。
- 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

---
# 2. 意图

- 定义一系列的算法把它们一个个封装起来，并且使它们可相互替换。策略模式使得算法可独立于使用它的客户而变化。
- 主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

---
# 3. 动机

- 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂：而且有时候支持不使用的算法也是一个性能负担。
- 如何在运行时根据需要透明地更改对象的算法? 将算法与对象本身解耦，从而避免上述问题?

---
# 4. 适用性

- 许多相关的类仅仅是行为有异：“策略” 提供了一种用多个行为中的一个行为来配置一个类的方法。
- 需要使用一个算法的不同变体：可能会定义一些反映不同的空间/时间权衡的算法。
- 算法使用客户不应该知道的数据：可使用策略模式以避免暴露复杂的、与算法相关的数据结构。
- 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现：将相关的条件分支移入它们各自的 Strategy 类中以代替这些条件语句。

---
# 5. 结构与参与者

> 策略模式

  ![策略模式](img/策略模式设计.png)

> 参与者

- Strategy：定义所有支持的算法的公共接口，Context 使用这个接口来调用某 ConcreteStrategy 定义的算法。
- ConcreteStrategy：以 Strategy 接口实现某具体算法。
- Context：用一个 ConcreteStrategy 对象来配置；维护一个对 Strategy 对象的引用；可定义一个接口来让 Stategy 访问它的数据。

> 协作

- Strategy 和 Context 相互作用以实现选定的算法。当算法被调用时, Context 可以将该算法所需要的所有数据都传递给该 Stategy。或 Context 可以将自身作为一个参数传递给 Strategy 操作。这就让 Strategy 在需要时可以回调 Context。
- Context 将它的客户的请求转发给它的 Strategy：客户通常创建并传递一个 ConcreteStrategy 对象给该 Context

---
# 6. 策略模式优缺点


---
# 7. 实现



---
# 8. 设计要点


---
# 9. 案例实现



> 案例示意

  ![案例](img/策略模式案例.png)

> 代码实现

1. [C# 实现]()
2. ...

---
# 10. 相关模式



---
## Visitor Pattern

- [Visitor Pattern](#visitor-pattern)
	- [访问者模式 (Visitor)](#访问者模式-visitor)
	- [模式设计](#模式设计)
		- [模式实现](#模式实现)
		- [访问者模式优缺点](#访问者模式优缺点)
	- [案例实现](#案例实现)
	- [相关模式](#相关模式)

---
### 访问者模式 (Visitor)

在访问者模式 (Visitor Pattern) 中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

> **意图**

- 意图：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
- 主要解决：**稳定的数据结构和易变的操作耦合问题**。
- 何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作 “污染” 这些对象的类，使用访问者模式将这些封装到类中。

> **动机**

- 在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为 (方法)，如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。
- 如何在不更改类层次结构的前提下，在运行时根据需要透明地为类层次结构上的各个类动态添加新的操作，从而避免上述问题?

> **适用性**

- 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作：当该对象结构被很多应用共享时，用 Visitor 模式让每个应用仅包含需要用到的操作。
- 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。
  
>---
### 模式设计

> **访问者模式**

  ![访问者模式](img/访问者模式设计.png)

> **参与者**

- Visitor：访问者，为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作。该操作的名字和特征标识了发送 Visit 请求给该访问者的那个类。这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它。
- ConcreteVisitor：具体访问者，实现每个由 Visitor 声明的操作。每个操作实现本算法的一部分，而该算法片断乃是对应于结构中对象的类。ConcreteVisitor 为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。
- Element：元素，定义一个 Accept 操作，它以一个访问者为参数。
- ConcreteElement：具体元素，实现 Accept 操作，该操作以一个访问者为参数。
- ObjectStructure：对象结构，能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素。可以是一个复合或是一个集合，如一个列表或一个无序集。

> **协作**

- 一个使用 Visitor 模式的客户必须创建一个 ConcreteVisitor 对象，然后遍历该对象结构，并用该访问者访问每一个元素。
- 当一个元素被访问时，它调用对应于它的类的 Visitor 操作。如果必要，该元素将自身作为这个操作的一个参数以便该访问者访问它的状态。

#### 模式实现

1. 每一个对象结构都有一个相关的 Visitor 类。这个抽象的访问者类为定义对象结构的每一个 ConcreteElement 类声明一个 VisitConcreteElement 操作。
2. 每个 ConcreteElement 类实现一个 Accept 操作。
3. 应用 Visitor 时产生的两个实现问题：
   - 双分派 (Double-dispatch) ：访问者模式允许你不改变类即可有效地增加其上的操作。
   - 谁负责遍历对象结构：一个访问者必须访问这个对象结构的每一个元素。

> **设计要点**

- Visitor 模式通过所谓双重分发 (double-dispatch) 来实现在不更改 Element 类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作。
- 所谓双重分发即 Visitor 模式中间包括了两个多态分发 (注意其中的多态机制)：第一个为 accept 方法的多态辨析；第二个为 visit 方法的多态辨析。
- Visitor 模式的最大缺点在于扩展类层次结构 (增添新的 Element 子类)，会导致 Visitor 类的改变。因此 Vistor 模式适用于 “Element 类层次结构稳定，而其中的操作却经常面临频繁改动”。

#### 访问者模式优缺点

1. 访问者模式使得易于增加新的操作：访问者使得增加依赖于复杂对象结构的构建的操作变得简单。
2. 访问者集中相关的操作而分离无关的操作：相关的行为不是分布在定义该对象结构的类上而是集中在一个访问者中。
3. 增加新的 ConcreteElement 类很困难：每增加一个 ConcreteElement 要在 Visitor 中添加一个新的抽象操作，且在每个 Concrete 中实现相应的操作。
4. 通过类层次进行访问：一个迭代器可以通过调用节点对象的特定操作遍历整个对象结构，同时访问这些对象。
5. 累积状态：当访问者访问对象结构中的每一个元素时，可能会累积状态。
6. 破坏封装：访问者方法常常需要被访问元素提供访问内部状态的公共操作，可能会破坏封装。

>---
### 案例实现

创建一个定义接受操作的 ComputerPart 接口。Keyboard、Mouse、Monitor 和 Computer 是实现了 ComputerPart 接口的实体类。我们将定义另一个接口 ComputerPartVisitor，它定义了访问者类的操作。Computer 使用实体访问者来执行相应的动作。

> **案例示意**

  ![案例](img/访问者模式案例.png)

> **代码实现**

1. [C# 实现](../../_DP_04_程序参考/DesignPatterns%20For%20CSharp/Behavioral%20Patterns/Visitor/Visitor.cs)
2. ...

>---
### 相关模式

- Composite：访问者可以用于对一个由 Composite 模式定义的对象结构进行操作。
- Interpreter：访问者可以用于解释。

---